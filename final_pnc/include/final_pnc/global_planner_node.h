
#pragma once
#include <ros/ros.h>
#include <nav_core/base_global_planner.h>
#include <geometry_msgs/PoseStamped.h>
#include <nav_msgs/GetPlan.h>
#include <costmap_2d/costmap_2d_ros.h>
#include <costmap_2d/costmap_2d.h>
#include <tf/transform_listener.h>

#include "global_planner.h"
#include "dynamicvoronoi.h"

class GlobalPlanner
{
public:
    // GraphPlanner();

    /**
     * @brief Construct a new Graph Planner object
     * @param name        planner name
     * @param costmap_ros the cost map to use for assigning costs to trajectories
     */
    GlobalPlanner(ros::NodeHandle *nh, std::string name);

    /**
     * @brief Destroy the Graph Planner object
     */
    ~GlobalPlanner();

    /**
     * @brief Plan a path given start and goal in world map
     * @param start start in world map
     * @param goal  goal in world map
     * @param plan  plan
     * @return true if find a path successfully, else false
     */
    bool makePlan(const geometry_msgs::PoseStamped &start, const geometry_msgs::PoseStamped &goal,
                  std::vector<geometry_msgs::PoseStamped> &plan);

    /**
     * @brief Plan a path given start and goal in world map
     * @param start     start in world map
     * @param goal      goal in world map
     * @param plan      plan
     * @param tolerance error tolerance
     * @return true if find a path successfully, else false
     */
    bool makePlan(const geometry_msgs::PoseStamped &start, const geometry_msgs::PoseStamped &goal, double tolerance,
                  std::vector<geometry_msgs::PoseStamped> &plan);

    /**
     * @brief Publish planning path
     * @param path planning path
     */
    void publishPlan(const std::vector<geometry_msgs::PoseStamped> &plan);

    /**
     * @brief Regeister planning service
     * @param req  request from client
     * @param resp response from server
     */
    bool makePlanService(nav_msgs::GetPlan::Request &req, nav_msgs::GetPlan::Response &resp);

    void gridmapCallback(const nav_msgs::OccupancyGrid::ConstPtr &msg);

    void gridmapUpdateCallback(const map_msgs::OccupancyGridUpdate::ConstPtr &msg);

protected:
    /**
     * @brief publish expand zone
     * @param expand set of expand nodes
     */
    void _publishExpand(std::vector<Node> &expand);

    /**
     * @brief Calculate plan from planning path
     * @param path path generated by global planner
     * @param plan plan transfromed from path, i.e. [start, ..., goal]
     * @return bool true if successful, else false
     */
    bool _getPlanFromPath(std::vector<Node> &path, std::vector<geometry_msgs::PoseStamped> &plan);

protected:
    bool initialized_;                         // initialization flag
    int nx_, ny_;                              // costmap size
    double resolution_;                        // costmap resolution
    std::string frame_id_;                     // costmap frame ID
    std::string planner_name_;                 // planner name
    global_planner::GlobalPlanner *g_planner_; // global graph planner
    ros::Publisher plan_pub_;                  // path planning publisher
    ros::Publisher expand_pub_;                // nodes explorer publisher
    ros::ServiceServer make_plan_srv_;         // planning service

private:
    bool is_outline_;           // whether outline the boudary of map
    bool is_expand_;            // whether publish expand map or not
    bool is_voronoi_map_;       // whether to store Voronoi map or not
    double convert_offset_;     // offset of transform from world(x,y) to grid map(x,y)
    double tolerance_;          // tolerance
    double factor_;             // obstacle inflation factor
    boost::mutex mutex_;        // thread mutex
    DynamicVoronoi voronoi_;    // dynamic voronoi map
    ros::NodeHandle *nh_;       // ROS node handle
    tf::TransformListener *tf_; // transform listener
    float origin_x_, origin_y_; // origin of costmap
    nav_msgs::OccupancyGrid gridmap_; // grid map
    ros::Subscriber gridmap_sub_; // costmap subscriber
    ros::Subscriber gridmap_update_sub_; // costmap update subscriber
    unsigned char* charmap_; // char map

    ros::Publisher gridmap_pub_; // costmap publisher

};